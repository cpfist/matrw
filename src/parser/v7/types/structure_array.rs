use binrw::*;

use crate::interface::types::structure_array::StructureArray;
use crate::parser::v7::flags::{MatFileDataTypes, MatlabArrayTypes};
use crate::parser::v7::types::subelements::array_dimensions::ArrayDimensions;
use crate::parser::v7::types::subelements::array_fieldname::ArrayFieldNames;
use crate::parser::v7::types::subelements::array_flags::ArrayProps;
use crate::parser::v7::types::subelements::array_name::ArrayName;
use crate::parser::v7::variable7::MatVariable7;

use super::subelements::array_flags::ArrayFlagBits;

#[binrw]
#[derive(Debug, Clone)]
#[br(assert(data_type == MatFileDataTypes::MiMATRIX &&
            props.array_class == MatlabArrayTypes::MxSTRUCTCLASS))]
pub struct StructureArray7 {
    #[brw(pad_size_to = 4)]
    data_type: MatFileDataTypes,
    #[bw(calc = self.size_data())]
    _num_bytes: u32,
    props: ArrayProps,
    #[brw(align_after = 8)]
    dimensions: ArrayDimensions,
    #[brw(align_after = 8)]
    name: ArrayName,
    #[brw(align_after = 8)]
    fieldnames: ArrayFieldNames,
    #[br(count = fieldnames.field_number*
        dimensions.dim().iter().product::<u32>(), align_after = 8)]
    value: Vec<MatVariable7>,
}

impl StructureArray7 {
    pub fn new(dim: Vec<u32>, field_strings: Vec<String>, value: Vec<MatVariable7>) -> Self {
        let name = "".to_string();

        let props = ArrayProps::new(
            MatlabArrayTypes::MxSTRUCTCLASS,
            ArrayFlagBits::new(false, false, false),
            0,
        );
        let dimensions = ArrayDimensions::new(dim);
        let name = ArrayName::new(name);
        let fieldnames = ArrayFieldNames::new(field_strings);

        Self {
            data_type: MatFileDataTypes::MiMATRIX,
            props,
            dimensions,
            name,
            fieldnames,
            value,
        }
    }
    pub fn set_name(&mut self, name: &str) {
        self.name = ArrayName::new(name.to_string())
    }
    pub fn name(&self) -> String {
        self.name.name()
    }
    pub fn size_data(&self) -> u32 {
        let mut num_bytes = 0;
        num_bytes += self.props.size();
        num_bytes += self.dimensions.size();
        num_bytes += self.name.size();
        num_bytes += self.fieldnames.size();
        for val in self.value.iter() {
            num_bytes += val.size() as u32
        }

        num_bytes
    }
    pub fn size(&self) -> usize {
        self.size_data() as usize + 8
    }
    pub fn dim(&self) -> &Vec<u32> {
        self.dimensions.dim()
    }
    pub fn fieldnames(&self) -> Vec<String> {
        self.fieldnames.fieldnames()
    }
    pub fn value(self) -> Vec<MatVariable7> {
        self.value
    }
}

impl From<StructureArray> for StructureArray7 {
    fn from(value: StructureArray) -> Self {
        let fieldnames = value.fieldnames();
        let dim = value.dim.into_iter().map(|x| x as u32).collect();
        let mut val = vec![];
        for v in value.value.into_iter() {
            for w in fieldnames.clone().into_iter() {
                val.push(v[w.as_str()].clone().into())
            }
        }

        Self::new(dim, fieldnames, val)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use binrw::BinReaderExt;
    use binrw::io::Cursor; // A no_std reimplementation of std::io // extension traits for use with readers and writers

    /// Binary representation of a mat file containing a variable `A` with a cell array.
    /// To reproduce, in a MATLAB session with a clean workspace run
    /// `>> s(1).a = 42;`
    /// `>> s(1).b = 43;`
    /// `>> s(2).a = 52;`
    /// `>> s(2).b = 53;`
    /// `>> save('example.mat', 's', '-nocompression');`
    ///
    const STRUCT_ARRAY2: [u8; 296] = [
        0x0e, 0x00, 0x00, 0x00, 0x20, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x73, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04,
        0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x62,
        0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x01, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x34, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x2b, 0x00,
        0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x01, 0x00, 0x35, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn parse_struct_array2() {
        let data = Cursor::new(&STRUCT_ARRAY2).read_le::<StructureArray7>().unwrap();
        println!("Deserialized data: {:#?}", data);
    }

    /// Binary representation of a mat file containing a variable `A` with a cell array.
    /// To reproduce, in a MATLAB session with a clean workspace run
    /// `>> s(1,1).a = 42;`
    /// `>> s(1,2).a = 43;`
    /// `>> s(2,1).a = 44;`
    /// `>> s(2,2).a = 45;`
    /// `>> s(1,1).b = 52;`
    /// `>> s(1,2).b = 53;`
    /// `>> s(2,1).b = 54;`
    /// `>> s(2,2).b = 55;`
    /// `>> save('test.mat','s','-nocompression')
    ///
    const STRUCT_ARRAY3: [u8; 520] = [
        0x0e, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x73, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04,
        0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x62,
        0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x01, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x34, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x2c, 0x00,
        0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x01, 0x00, 0x36, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x35, 0x00, 0x00, 0x00,
        0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01,
        0x00, 0x2d, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x37, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn parse_struct_array3() {
        let data = Cursor::new(&STRUCT_ARRAY3).read_le::<StructureArray7>().unwrap();
        println!("Deserialized data: {:#?}", data);
    }
}
