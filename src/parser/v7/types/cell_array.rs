use binrw::*;

use crate::interface::types::cell_array::CellArray;
use crate::parser::v7::flags::{MatFileDataTypes, MatlabArrayTypes};
use crate::parser::v7::types::subelements::array_dimensions::ArrayDimensions;
use crate::parser::v7::types::subelements::array_flags::{ArrayFlagBits, ArrayProps};
use crate::parser::v7::types::subelements::array_name::ArrayName;
use crate::parser::v7::variable7::MatVariable7;

#[binrw::writer(writer, endian)]
#[allow(clippy::ptr_arg)]
pub fn write_value(data: &Vec<MatVariable7>) -> BinResult<()> {
    for val in data.iter() {
        let _ = val.write_options(writer, endian, ());
    }

    Ok(())
}

#[binrw]
#[derive(Debug, Clone)]
#[br(assert(data_type == MatFileDataTypes::MiMATRIX &&
            props.array_class == MatlabArrayTypes::MxCELLCLASS))]
pub struct CellArray7 {
    #[brw(pad_size_to = 4)]
    data_type: MatFileDataTypes,
    #[bw(calc = self.size_data())]
    _num_bytes: u32,
    props: ArrayProps,
    #[brw(align_after = 8)]
    dimensions: ArrayDimensions,
    #[brw(align_after = 8)]
    name: ArrayName,
    #[br(count = dimensions.dim().iter().product::<u32>())]
    #[bw(write_with = write_value)]
    value: Vec<MatVariable7>,
}

impl CellArray7 {
    pub fn new(name: String, dim: Vec<u32>, value: Vec<MatVariable7>) -> Self {
        let props = ArrayProps::new(
            MatlabArrayTypes::MxCELLCLASS,
            ArrayFlagBits::new(false, false, false),
            0,
        );
        let dimensions = ArrayDimensions::new(dim);
        let name = ArrayName::new(name);

        Self {
            data_type: MatFileDataTypes::MiMATRIX,
            props,
            dimensions,
            name,
            value,
        }
    }
    pub fn set_name(&mut self, name: &str) {
        self.name = ArrayName::new(name.to_string())
    }
    pub fn name(&self) -> String {
        self.name.name()
    }
    pub fn size_data(&self) -> u32 {
        let mut num_bytes = 0;
        num_bytes += self.props.size();
        num_bytes += self.dimensions.size();
        num_bytes += self.name.size();
        for val in self.value.iter() {
            num_bytes += val.size() as u32
        }

        num_bytes
    }
    pub fn size(&self) -> usize {
        self.size_data() as usize + 8
    }
    pub fn dim(&self) -> Vec<u32> {
        self.dimensions.dim().clone()
    }
    pub fn value(self) -> Vec<MatVariable7> {
        self.value
    }
}

impl From<CellArray> for CellArray7 {
    fn from(value: CellArray) -> Self {
        let dim = value.dim.into_iter().map(|x| x as u32).collect();
        let mut val = vec![];
        for v in value.value.into_iter() {
            val.push(v.into())
        }

        Self::new("".to_string(), dim, val)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::v7::types::numeric_array::{NumericArray7, NumericArrayNew};
    use crate::parser::v7::types::structure::Structure7;
    use crate::parser::v7::types::structure_array::StructureArray7;
    use binrw::BinReaderExt;
    use binrw::io::Cursor; // A no_std reimplementation of std::io // extension traits for use with readers and writers

    /// Binary representation of a MAT-file containing an empty cell array.
    /// To reproduce, in a MATLAB session with a clean workspace run
    /// `>> var_empty = {};`
    /// `>> save('example.mat', 'var_empty', '-nocompression');`
    ///
    const DATA_CELL_EMPTY: [u8; 64] = [
        0x0e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x76, 0x61, 0x72,
        0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn deserialize_cell_empty() {
        let mut bin = Cursor::new(&DATA_CELL_EMPTY);
        let data = bin.read_le::<CellArray7>().unwrap();
        println!("Deserialized data: {:#?}", data);
    }

    #[test]
    fn serialize_cell_empty() {
        let mut bin = Cursor::new(vec![]);

        let data = CellArray7::new("var_empty".to_string(), vec![0, 0], vec![]);
        println!("data: {:#?}", &data);
        data.write_le(&mut bin).unwrap();

        let inner = bin.into_inner();
        println!("Orig bin: {:?}", DATA_CELL_EMPTY);
        println!("Ser  bin: {:?}", &inner);
        assert_eq!(inner, DATA_CELL_EMPTY);
    }

    /// Binary representation of a mat file containing a variable `C` with a cell array.
    /// To reproduce, in a MATLAB session with a clean workspace run
    /// `>> A = [ 1,2,3; 4,5,6 ];`
    /// `>> B = [ 7,8,9; 10,11,12 ];`
    /// `>> C = { A, B };`
    /// `>> save('example.mat', 'C');`
    ///
    const DATA_CELL_NUMERIC: [u8; 176] = [
        0x0e, 0x00, 0x00, 0x00, 0xa8, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x43, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x01, 0x04, 0x02, 0x05, 0x03, 0x06, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00,
        0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x07, 0x0a,
        0x08, 0x0b, 0x09, 0x0c, 0x00, 0x00,
    ];

    #[test]
    fn deserialize_cell_1() {
        let mut bin = Cursor::new(&DATA_CELL_NUMERIC);
        let data = bin.read_le::<CellArray7>().unwrap();
        println!("Deserialized data: {:#?}", data);
    }

    #[test]
    fn serialize_cell_1() {
        let mut bin = Cursor::new(vec![]);

        let var1 = MatVariable7::Numeric(NumericArray7::new(vec![2, 3], vec![1., 4., 2., 5., 3., 6.], None));
        let var2 = MatVariable7::Numeric(NumericArray7::new(
            vec![2, 3],
            vec![7., 10., 8., 11., 9., 12.],
            None,
        ));

        let data = CellArray7::new("C".to_string(), vec![1, 2], vec![var1, var2]);
        println!("data: {:#?}", &data);
        data.write_le(&mut bin).unwrap();

        let inner = bin.into_inner();
        println!("Orig bin: {:?}", DATA_CELL_NUMERIC);
        println!("Ser  bin: {:?}", &inner);
        assert_eq!(inner, DATA_CELL_NUMERIC);
    }

    /// Binary representation of a mat file containing a variable `A` with a cell array.
    /// To reproduce, in a MATLAB session with a clean workspace run
    /// `>> A = struct('a', 42.0);`
    /// `>> B = [ 1, 2, 3, 4 ];`
    /// `>> C = { A, B };`
    /// `>> save('example.mat', 'C');`
    ///
    const DATA_CELL_STRUCT_AND_NUMERIC: [u8; 232] = [
        0x0e, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x43, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
        0x00, 0x78, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x05, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x01, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x01, 0x02, 0x03, 0x04,
    ];

    #[test]
    fn deserialize_cell_struct_and_numeric() {
        let mut bin = Cursor::new(&DATA_CELL_STRUCT_AND_NUMERIC);
        let data = bin.read_le::<CellArray7>().unwrap();
        println!("Deserialized data: {:#?}", data);
    }

    #[test]
    fn serialize_cell_struct_and_numeric() {
        let mut bin = Cursor::new(vec![]);

        let var1 = MatVariable7::Structure(Structure7::new(
            vec!["a".to_string()],
            vec![MatVariable7::Numeric(NumericArray7::new(
                vec![1, 1],
                vec![42.0],
                None,
            ))],
        ));
        let var2 = MatVariable7::Numeric(NumericArray7::new(vec![1, 4], vec![1., 2., 3., 4.], None));

        let data = CellArray7::new("C".to_string(), vec![1, 2], vec![var1, var2]);
        println!("data: {:#?}", &data);
        data.write_le(&mut bin).unwrap();

        let inner = bin.into_inner();
        println!("Orig bin: {:?}", DATA_CELL_STRUCT_AND_NUMERIC);
        println!("Ser  bin: {:?}", &inner);
        assert_eq!(inner, DATA_CELL_STRUCT_AND_NUMERIC);
    }

    /// Binary representation of a mat file containing a variable `A` with a cell array.
    /// To reproduce, in a MATLAB session with a clean workspace run
    /// `>> A(1,1).a = 42.0;`
    /// `>> A(1,1).b = 43.0;`
    /// `>> A(1,2).a = 44.0;`
    /// `>> A(1,2).b = 45.0;`
    /// `>> B = [ 1, 2, 3, 4 ];`
    /// `>> C = { A, B };`
    /// `>> save('example.mat', 'C');`
    ///
    const DATA_CELL_STRUCTARRAY_AND_NUMERIC: [u8; 400] = [
        0x0e, 0x00, 0x00, 0x00, 0x88, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x43, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
        0x00, 0x20, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x03, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00,
        0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x01, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x0e,
        0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00,
        0x2d, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x04, 0x00, 0x01, 0x02, 0x03, 0x04,
    ];

    #[test]
    fn deserialize_cell_structarray_and_numeric() {
        let mut bin = Cursor::new(&DATA_CELL_STRUCTARRAY_AND_NUMERIC);
        let data = bin.read_le::<CellArray7>().unwrap();
        println!("Deserialized data: {:#?}", data);
    }

    #[test]
    fn serialize_cell_structarray_and_numeric() {
        let mut bin = Cursor::new(vec![]);

        let var1 = MatVariable7::StructureArray(StructureArray7::new(
            vec![1, 2],
            vec!["a".to_string(), "b".to_string()],
            vec![
                MatVariable7::Numeric(NumericArray7::new(vec![1, 1], vec![42.0], None)),
                MatVariable7::Numeric(NumericArray7::new(vec![1, 1], vec![43.0], None)),
                MatVariable7::Numeric(NumericArray7::new(vec![1, 1], vec![44.0], None)),
                MatVariable7::Numeric(NumericArray7::new(vec![1, 1], vec![45.0], None)),
            ],
        ));
        let var2 = MatVariable7::Numeric(NumericArray7::new(vec![1, 4], vec![1., 2., 3., 4.], None));

        let data = CellArray7::new("C".to_string(), vec![1, 2], vec![var1, var2]);
        println!("data: {:#?}", &data);
        data.write_le(&mut bin).unwrap();

        let inner = bin.into_inner();
        println!("Orig bin: {:?}", DATA_CELL_STRUCTARRAY_AND_NUMERIC);
        println!("Ser  bin: {:?}", &inner);
        assert_eq!(inner, DATA_CELL_STRUCTARRAY_AND_NUMERIC);
    }

    /// Binary representation of a mat file containing a variable `A` with a cell array.
    /// To reproduce, in a MATLAB session with a clean workspace run
    /// `>> A = { 42.0, 43.0 };`
    /// `>> B = [ 1, 2, 3, 4 ];`
    /// `>> C = { A, B };`
    /// `>> save('example.mat', 'C');`
    ///
    const DATA_CELL_CELL_AND_NUMERIC: [u8; 264] = [
        0x0e, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x43, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
        0x00, 0x98, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x0e,
        0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00,
        0x2b, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x04, 0x00, 0x01, 0x02, 0x03, 0x04,
    ];

    #[test]
    fn deserialize_cell_cell_and_numeric() {
        let mut bin = Cursor::new(&DATA_CELL_CELL_AND_NUMERIC);
        let data = bin.read_le::<CellArray7>().unwrap();
        println!("Deserialized data: {:#?}", data);
    }

    #[test]
    fn serialize_cell_cell_and_numeric() {
        let mut bin = Cursor::new(vec![]);

        let var1 = MatVariable7::Cell(CellArray7::new(
            "".to_string(),
            vec![1, 2],
            vec![
                MatVariable7::Numeric(NumericArray7::new(vec![1, 1], vec![42.0], None)),
                MatVariable7::Numeric(NumericArray7::new(vec![1, 1], vec![43.0], None)),
            ],
        ));
        let var2 = MatVariable7::Numeric(NumericArray7::new(vec![1, 4], vec![1., 2., 3., 4.], None));

        let data = CellArray7::new("C".to_string(), vec![1, 2], vec![var1, var2]);
        println!("data: {:#?}", &data);
        data.write_le(&mut bin).unwrap();

        let inner = bin.into_inner();
        println!("Orig bin: {:?}", DATA_CELL_CELL_AND_NUMERIC);
        println!("Ser  bin: {:?}", &inner);
        assert_eq!(inner, DATA_CELL_CELL_AND_NUMERIC);
    }

    /// Binary representation of a mat file containing a variable `A` with a cell array.
    /// To reproduce, in a MATLAB session with a clean workspace run
    /// `>> A = "Some string";`
    /// `>> B = [ 1, 2, 3, 4 ];`
    /// `>> C = { A, B };`
    /// `>> save('example.mat', 'C');`
    ///
    const DATA_CELL_MCOS_AND_NUMERIC: [u8; 1240] = [
        0x0e, 0x00, 0x00, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x43, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x4d,
        0x43, 0x4f, 0x53, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
        0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdd, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x01, 0x02,
        0x03, 0x04, 0x0e, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0xb0, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0xb0, 0x03, 0x00, 0x00, 0x00, 0x01, 0x49, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00,
        0x00, 0x00, 0x10, 0x03, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x05,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4d, 0x43, 0x4f, 0x53, 0x00, 0x00,
        0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xc8, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x04, 0x00, 0x4d, 0x43, 0x4f, 0x53, 0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x46,
        0x69, 0x6c, 0x65, 0x57, 0x72, 0x61, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x5f, 0x00, 0x00, 0x00, 0x0e, 0x00,
        0x00, 0x00, 0x88, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xe8,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x70,
        0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xa8, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x6e, 0x79, 0x00, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53,
        0x00, 0x6f, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x20, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00, 0x69, 0x00,
        0x6e, 0x00, 0x67, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xa8, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
        0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x38,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
        0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x01, 0x49, 0x4d,
        0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x04, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x4d, 0x43, 0x4f, 0x53, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn deserialize_cell_mcos_and_numeric() {
        let mut bin = Cursor::new(&DATA_CELL_MCOS_AND_NUMERIC);
        let data = bin.read_le::<CellArray7>().unwrap();
        println!("Deserialized data: {:#?}", data);
    }
}
